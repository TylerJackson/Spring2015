CSE 7349 Data and Network Security Lecture Notes

---------------------------------------------------------

Data and Network Security Lecture 1 Notes

Dr. Nair
-best contact through email
- nair@lyle.smu.edu
-office hours MW 1-2 PM or by appointment

--------------------------------------------------------

Data and Network Security Lecture 2 Notes

Software Security Current Events
-DDos attacks over holiday on Sony

University Networks are vulnerable
-have to be somewhat open, but still have sensitive information

Cryptography
-Terminology
-Cryptology - the art and science of making and breaking secret codes
-cryptography - making secret codes
-cryptanalysis - breaking secret codes
-crypto - all the above

-cipher or cryptosystem is used to encrypt the plaintext
-result of encryption is ciphertext
-we decrypt ciphertext to recover plaintext
-a key is used to configure a cryptosystem
-a symmetric key cryptosystem uses the same key to encrypt as to decrypt
-a public key cryptosystem uses a public key to encrypt and a private key to decrypt (sign)

Crypto Designs
-Basic assumption
	-the system is completely known to attacker
	-only the key is secret
-aka Kerchoff's Principle
	-crpyto algorithms are not secret
-why do we make this assumption?
	-experience has shown that secret algorithms are weak when exposed
	-secret algorithms never remain secret
	-better to find weaknesses before hand

Cryptanalysis
-cryptosystem is secure if best known attack is to try all keys (exhaustive key search)
-cryptosystem is insecure if any shortcut attack is known
-by this definition an insecure system might be harder to break than a secure system!

One-time pad encryption
plaintext XOR key = ciphertext
-key has to be same size as plaintext
-stream cipher
-more efficient in hardware
-no integrity (no signature), can always repudiate
	-MiM attack could intercept message, and change key so that message says what you want

-in order to decrypt one-time pad, the receiver needs the key
-this is a large key to transmit-
-if you have a way to transport the key securely than just use that for message
-in general, the key needs to be much shorter than message

Taxonomy of Cryptography
-symmetric key
	-same key for encryption as for decryption
	-stream ciphers
		-bit patterns come in and encrypt as they are read in
	-block ciphers
		-take a block and encrypt it
-public key
	-two keys, one for encryption (public), and one for decryption (private)
	-digital signatures - nothing comparable in symmetric key crypto
	-can authenticate using PKI, b.c. of non-repudiation
-hash algorithms
	-good for integrity
	-good hash means if change only 1 bit then different hash value

Data Encryption Standard
-DES developed in 1970s
-based on IBM Lucifer cipher
-U.S. gov't standard
-DES development was controvercial
	-NSA was secretly involved
	-Design process was not open
	-Key length was reduced
	-subtle changes to Lucifer algorithm

DES Numerology
-DES is a Feistel Cipher
	-64 bit block length
	-56 bit key length
	-16 rounds
	-48 bits of key used each round (subkey)
-Each round is simple (for a block cipher)
-Security depends primarily on S-boxes
	-each S-boxes maps 6 bits to 4 bits
-could strengthen DES by using 3DES encrypt with first key, decrypt with a second key, and re-encrypt with the original key
	-3DES has 128 bit key

	DES
-complexity is 2^55
-Feistel Cipher (16 rounds)
	-can't affect this or S-Box
-Meet in the Middle attack for 2 DES encryptions in succession with different keys
	-collect a plain text and ciphertext from the end
	-brute force the ciphertext after the first DES box for all 2^56 K1 possibilities
	-brute force the plaintext from the second DES box using all 2^56 K2 possibilities
	-then using the cipher text from box 1 and plaintext from box2 find matches
	-so it is complexity 2^56
-known plaintext attack- you know a small piece of plaintext and the corresponding ciphertext
	-can determine key from this maybe
	-your email address in an email
-lunchtime attack
	-someone left their system logged in, so you generate a ciphertext using their system

	3DES
-both people have to use 3DES or it won't work
-in order to turn a 3DES into DES just set K1 = K2

Confusion and Diffusion
-Cipher needs to completely obscure statistical properties of original message
-Diffusion - dissipates statistical structure of plaintext over bulk of cipher text
-confusion - makes relationship between ciphertext and key as complex as possible

-avalance effect
	-concept that a change in 1 bit will lead to large changes in the ciphertext
	-with round function easy, because your 1 bit error will increase more and more each round

Electronic Code Book
-message broken into independent blocks which are encrypted
-each block is a value which is substituted, like a codebook, hence name
-each block encoded independently of the other blocks C_1 = DES_K1 (P_1)
-uses: secure transmission of single values
-problem is same plaintext always results in same ciphertext
-repeated key in other words

Advantages and limitations of ECB
-repetitions in message may show in ciphertext
	-if aligned with message block
	-messages that change very little, which become a code-book analysis problem
-weakness due to encrypted message blocks being independent 
-main use is sending a few blocks of data 

Cipher Block Chaining (CBC)
-take ciphertext from previous block and XOR with plaintext of block 2 and then encrypt block 2 and so on and so forth
-use an IV to XOR with initial plaintext
-IV needs to be known by receiver

--------------------------------------------------------

Data and Network Security Lecture 3 Notes

Current Events

if attack will cause you to lose more than $10,000 then FBI will pick up the case

Singapore is going to start agency like NSA

-look at blackboard for links to sec current events

Google alerts for cyber security
-Google News


Cipher Block Chaining Continued
-error in 1 cipher bit results in 2 plaintext bit errors, but that is all, it won't get propagated further

Cipher FeedBack Mode (CFB)
-use schemes so that you can encrypt smaller amounts of data
-use 8 bits at a time
-if trying to use DES
	-add dummy bits (padding)
-so you can still use DES, but you are still transmitting 64 bits, unecessarily using the bandwidth
-these kind of schemes help wit this problem
-Process
	-IV -> encrypt it using key K and DES
	-using first S-bits (8 in this case) of the encrypted IV and XOR with plaintext
		-result is cipher
	-then feed this 8 bit ciphertext back to far right of initial register and push 8 bits off the left end, so that the IV changes each time
-this still chains the encryption blocks, but doesn't require you to ship any padding bits
-the error will propagate through for each plain text until the error bit is off the IV 
	-so if our IV is 64 bits as it is in this case (B.C. we are using DES) then there would be 9 plain text errors
-if an error in C1, then P1 is wrong and 

Output FeedBack
-similar to Cipher Feedback, but the error doesn't propagate through
-Process
	-start with 64 bit IV and encrypt using DES and your key
	-take the first S-bits from this encrypted IV and XOR with the plaintext
		-the result is the ciphertext for the first 8 bits
	-the difference is that instead of passing on the ciphertext to the next IV and pushing the left 8 bits off, we will use the encrypted IV from the previous encryption as the IV for the start of the next encryption
		-so the 2nd encryption will encrypt the IV for the second time using your key and DES
-if there is an error in the ciphertext of 1 it won't matter, because it is the encrypted IV that gets propagated

Counter (CTR) mode
-similar to OFB but encrypts counter value rather than any fed back value
-Must have a different key and counter value for every plaintext block (never reused)
 C1 = P1 XOR O1
 O1 = DES_K1(1)
-uses high-speed network encryptions
-Process
	-take a 64 bit counter and encrypt it using key and DES
	-then whatever output is, XOR with plaintext
	-then increase counter, and repeat for next plaintext block
-powerful because can encrypt multiple blocks at once so can use parallel programming
	-block encryption is not dependent on previous block's plaintext
	-all the IV from the counters that get encrypted using key can be precomputed

-AES History
-in 1999 NIST said 3DES should be used
	-168 bit key length, same algorithm as DES
-3DES has drawbacks
	-algorithm is sluggish in software
	-only uses 64 bit block size

AES
-128 bit or more key
-when being created said it needed to be more computationally complex, and faster than DES and 3DES
-diffusion and confusion
-substitution -> confusion
-mixed rows and cols -> diffusion
-more rounds -> more confusion
-secure, because best known attack is exhaustive key search, which is computationally infeasible giving computing capacity

Difference b.w. stream cipher and block cipher
-stream cipher encrypts as it comes in, while block cipher buffers data into blocks, encrypts, and then send
-any block encryption scheme can be used as a stream cipher

Rule for Onetime Pad?
-never reuse key

Block vs Stream
-Block ciphers
	-process plaintext in relatively large blocks (64 for DES)
	-the same function is used to encrypt successive blocks -> memory less
-Stream ciphers
	-process plaintext in small blocks
	-the encryption function may vary as plaintext is processed -> have memory
	-sometimes called state ciphers since encryption depends on not only the key and plaintext, but also the current state

One-time pad
-provably secure
	-key generated randomly and independently - no integrity checks
	-key as long as plaintext
	-must never reuse stream key
		-if you reuse the key
	-P1 XOR K1 P2 XOR K2 .... Pn XOR K1
	-attackers know there isn't an exhaustive set of keys
	-(P1 XOR K1) XOR (Pn XOR K1)
		= P1 XOR Pn
-stream cipher

Pseudo Random Generators
-compromise to computationally secure
	-instead of random, use pseudo random sequence based on a short key
	-the generated stream must be:
		statistically random (knowing part of seq. not enough)
-PRG may be controlled just by key influencing
	-next-state function (output feedback mode)
	-output function (counter mode)
-PRG may be controlled both by data and key:
	-output function (cipher feedback mode)
-pseudo random should have same number of 0s and 1s

Linear Feedback Shift Registers
-LFSRs
	-well-suited to hardware implementation
	-can produce sequences of large period
	-can produce sequences wth good statistical properties
-in a simple feed back during a left shift, whatever bit gets bumped off the left end will move to the first bit on the right

confusion means relationship between key and output and plaintext and output is completely uncorrelated

diffusion means statistics about ciphertext is completely removed-> no patterns

-take multiple LFSRs and combine them using nonlinear combination function to get your pseudo random sequence
	-balanced, non-linear, correlation immune

RC4
-used in WEP (WEP was replaced by WPA-2)
-1 of most popular stream ciphers 
-start with all combinations of 8 bits in a state machine 
	-when you get 8 bits you use that corresponding state machine and then the bits related to that state machine change

WEP
-RC4
-key length 40, IV length = 24
-take message and add CRC (to protect and correct burst errors)
-then it goes into keysteam = RC(IV,K)
-IV attached to Cipher Text

Public Key Cryptography
-key is easily computed from the private key and other information about the cipher (a polynomial time (P-time) problem)
-however, knowing the public key and public description of the cipher, it is still computationally infeasible to compute the private key (an NP-Complete problem)
-public-key may be distributed to anyone wishing to communicate securely with its owner
	-secure distribution of the public-key is a non-trivial problem

Merkle's Puzzle
-one of the first public-key system to be described
-idea
	-A selects 1 million keys and 1 million puzzles to encode with them
	-sends to B 1 million encoded puzzles
	-B selects a random puzzle and brute force it to get the key (takes almost 2 minutes)
	-Encrypt the string with the key and send to A
	-A encrypts the string with million keys to find which key B selected
	-what is the complexity for the eavesdropper?


--------------------------------------------------------

Data and Network Security Lecture 4 Notes

Diffie-Hellman Key Exchange
-public information
	-p is a prime number
	-g is a generating element of Z_p
-Alice's 
	-private key: a
	-public key: g^a mod p
-Bob's
	-private key: b
	-public key: g^b mod p

-given g and p and g^a mod p it is very hard to solve for a
- key exchange
	-alice obtains g^b and computes 
		(g^b)^a = g^(ab) mod p = k_s
	-bob otains g^a and computes 
		(g^a)^b = g^(ab) mod p = k_s
	-Alice and Bob have agreed upon key k_s
	-The well-known man-in-the-middle attack exploits the lack of authentication

Man-in-the-middle
	-passive attack
		- wire tap
		-difficult to detect, dangerous
	-active attack
		-intercept signal, modify, and resend
		-easier to detect 
	-for this example, Eve creates a secret with Alice that is g^ae and creates a secret with Bob that is g^be

RSA
-Rivest, Shamir, Adleman in 1977
-best known and widely regarded as most practical public-key scheme
-based on exponentiation in a finite field over integers modulo a prime
-Security relies on the difficulty of calculating factors of large numbers

RSA Setup
-first, ecah user generates their public/private key pair by:
	-Selecting 2 large primes at random (-100 digit), p, q
	-Selecting at random the encryption key e, where e<N, gcd(e,phi(N)) = 1
	-solving the following congruence to find the decryption key d
	e,d = 1 mod phi(N) and 0<=d<=N
-public encryption key = {e,N}
-private decryption key = {d,p,q}
gcd= greatest common denominator
phi(N) = the number of numbers less than N that are relatively prime to N
	-relatively prime means greatest common factor is 1

N = pq
phi(N) = (p-1)*(g-1)
choose e s.t. e and phi(N) don't have common factors
-and e*d = 1

RSA
-to encrypt message M compute
	-> C = M^e mod N
-to decrypt C compute
	-> M = C^d mod N
-recall that e and N are public
-if attacker can factor N, he can use e to easily find d since ed = 1 mod (p-1)(q-1)
-factoring the modulus breaks RSA
-it is not known whether factoring is the only way to break RSA
-> M^e should be much larger than N
-cube root attack on RSA

Elliptic Curve Cryptography
-"elliptic curve" is a cryptosystem
-a different way to do the math in public key system
-elliptic curve versions DH, RSA, etc.
-elliptic curves may be more efficient
	-fewer bits are needed for same security
	-but the operations are more complex

Key Distribution

Where to put Encryption?
-Link level
	-vulnerable links equipped with encryption devices on both sides
	-needs large number of devices
	-needs decryption to perform routing
	-end nodes of each link will have a shared key
	-easier to share keys with neighbors
		-communicating only to physical neighbors
	-node 1 doesn't care where packet is going, b.c. only care that it is going to node 2
		-so you can encrypt header and body of packet, b.c. you don't need to see where it is going
-end to end
	-carried out at the end systems
	-can encrypt only the data portion and not the header
	-one key between start and finish
	-can't encrypt the header of the packet
	-never in between will encryption happen
-link level disadvantage
	-whole plaintext is available in between nodes
-end to end disadvantage
	-subject to traffic analysis
-end to end is more attractive logistically b.c. you only care about the end being able to decrypt
-a sys admin might like link level more b.c. back end encrypted more

Key Distribution
-most important in secure transmission
-options (b.w. A and B)
	-a selects a key and physically delivers it to B
	-a trusted third party key distribution center (KDC) selects a key and physically delivers it to A and B
	-if A and B already have a viable key, it can be used to distribute a new key
	-if A and B have a secure link to KDC, can receive the key through that channel

Using public key authority to communicate
-A requests B's public key from public key authority
	-encrypts this request with a timestamp and public key authority's public key
-public key authority decrypts the request using its private key
-public key authority responds to A with B's public key, and encrypts it with a timestamp and A' public key
-A decrypts the response with its private key
-Now A has B's public key and sends B a message with a nonce and encrypts it using B's public key
-if it is really B then B decrypts the message with its private key
-B then responds to A with the original nonce, and a second nonce and encrypts it with A's public key
	-he got A's public key in the same way that A got B's public key
-Since A is actually A, it decrpyts the message from B using its private key
-it then sends the second nonce back to B encrypted using B's public key, so that B knows it is really A
-B decrypts the message with his private key, and now they are authenticated

-reason for timestamps is to prevent replay attack, and to allow you to keep track of responses with requests

replay attack? not sure if this is right
-if someone compromised B's public key, and B knows that then B changes his public key.  However A doesn't know, so when A requests B's public key, Eve intercepts it and sends back to old public key for B
-Then A encrypts with the old public key, and Eve intercepts that message again, and can then decrypt it

Exchange of public-key certificates
-A sends public key to certificate authority, and authority repsonds with certificate (has timestamp, id, and public key) encrypted with authority's private key
-B can get a certificate for its public key as well
-then when A and B want to certificate they can just exchange signed certificates
	-faster than PKI b.c. don't need to contact PK authority every time
-security risk, b.c. certificate could get compromised

-with PKI you can get confidentiality, authenticity, or both

4 way handshake ??
-know how man in the middle attack could happen
-A sends a nonce to B encrypted with his public key
-A responsd with the 

-if A sends message to B and signs iwht A's private key
	-authenticity
-if A sends a message to B and signs iwht B's public key
	-confidentiality
-if A sends  amessage to B and signs with A's private key, and then encrypts with B's public key 
	-confidentiality and authenticity

Public-Key infrastructure (PKI)
-public key infrastructure (PKI) consists of all pieces needed to securely use public key cryptography
	-key generation and management
	-certificate authorities
	-certificate revocation (CRLs), etc.
-no general standard for PKI
-various "trust models"
-may have numerous trusted certificates from numerous CAs
-come up with secure infrastructure that can be used like a power system
	-same power from every outlet in house
	-same security from every authority


--------------------------------------------------------

Data and Network Security Lecture 5 Notes

Web of trust
-like transitive trust property
-20 people I trust trust someone so I will trust them

Message Authentication
-verify that messages come from the alleged source unaltered
	-authentication requirements
	-authentication functions
-MAC (mess. auth code)

Authentication Requirements
-masquerade
	-noone can pretend to be someone else
	-if someone says this is from me then we need to be able to verify this
-content modification
	-insertion, deletion, transposition, modification of message contents
-sequence modification 
	-insertion, deletion, reordering of sequenced messages
-timing modification
	-delay, replay
-repudiation
	-denial of message transmission or receipt

Authentication Functions
-message encryption
	-ciphertext itself serves as authenticator
	-if A sends message to B then A can encrypt with their shared secret key, and then B can decrypt with A's public key (this doesn't provide non-repud)
	-encryption for authenticity alone is overkill
	-A could encrypt with secret key in PKI and B decrypt with pub key of A to get authentication and non-repud
-message authentication code
	-public function combines message and secret key into fixed length value
	-take last round of a function and encrypt it with secret key
-hash function
	-public function maps message into fixed length value
	-if 1 bit changes then the hashed value will change
		-hopefully
	-if matching hash, then most likely message is good
	-sign the hash
	-encrypting hash of message is faster, b.c. message is fixed size, so encryption is faster
	-if you are only worried about authenticating then you can compare 2 encryptions and never have to decrypt

Message Authentication Code (MAC)
-cryptographic checksum
	-if any bits flipped, the checksum would change
	-easy to attack
	-just have to have an equal offset for every change you make
-mixes message with (shared) secret key to produce a fixed size block
-Assurances:
	-message has not been altered
	-message is from alleged sender
	-message sequence is unaltered (requires internal sequencing)
-MAC algorithm need not be reversible
	-can just encrypt and compare

CRC 
-checks for burst errors
-check sums with polynomials (a little harder to trick than linear check sum)

Why use MACs
	-why not just use encryption
-clear-text always clear
	-
-MAC might be cheaper
	-if you encrypt all binaries then it will be slow when hard drive loads it up b.c. has to decrypt everything
	-instead could just use integrity check using MACs
		(just want to make sure Word is Word Chrome is Chrome)
-Broadcast
	a message is sent out, anyone can use it but they must verify message is correct
	-1 computer could verify and if any other messages have that MAC then it is a good message
-Authentication of executables
-architectural flexibility
-separation of authentication check from message use
	-must decrypt before using if it was encrypted
	-now a days, you can start using it and after x clock cycles you can begin decrypting it, and 99% of time it is good so you saved some time, otherwise shut it down
-prolong the period of protection

Attacks on MACs
-if k<= n, one round should suffice
-other attacks are possible depending on the MAC algorithm
E.g. suppose C_k(M) = DES(k X1 XOR X2...Xm)
		-H is the XORs and then the hash is encrypted using DES
	-replace X by Y for i<m
	-Calculate Ym to produce the right checksum
		-Ym = Y1 XOR Y2 XOR... XOR Ym

		so now message is 
		 Y1  Y2  Y3  Y_strange

		 Y_strange = Y1 XOR Y2 XOR Y3 XOR XM
	In other words you can create any message you want, and then make the last value (the hash from the original message, m)

One-way Hash Functions
-converts a variable size message M into fixed size hash code H(M)
-Can be used with encryption for authentication
	-E(M || H)
	-M || E(H)
	-M || H(M || K)
	-E (M || signed H) gives confidentiality
	-M || H(M || K)
	-E(M || H(M || K))

Reverse Hash Chain
-have a hash chain and start form the back, so that people can not work backwards
-without H1 they can't get any other Hashes
-this is all assuming Hash is 1 way

Hash Requirements
-H is a weakly collision resistant: given x, it is computationally infeasible to find any x' s.t. H(x) = H(x')
	-find someone that has same birthday as you
-H is strongly collision resistant: it is computationally infeasible to find any x and any y s.t. H(x) = H(y)
	-find odds of anyone having the same birthday as anyone else
-one-way property is essential for authentication
-weak collision resistance is necessary to prevent forgery
-strong collision resistance is important for resistance to birthday attack



--------------------------------------------------------

Data and Network Security Lecture 6 Notes

Current Events

Anthem
-insurance company used phishing to get access to employee's computer and stole like 80 million client information
-risk is attackers will just hold onto their stolen information for a few years and then due an attack
-they are required to provide credit monitoring for 2 years to the people who got the id stolen
	-not enough

Hashes and Birthdays
-if h(x) is N bits, then 2^N different hash values are possible
-sqrt(2^N) = 2^(N/2)
-therefore, hash about 2^(N/2) random values and you expect to find a collision
-Implication: secure N bit symmetric key requires 2^(N-1) work to "break" while secure N bit hash requires 2^(N/2) work to "break"

Birthday attack (cont'd)

sender sends a message m with a hash
-receiver will get the message with the hash, compute the hash in real time, and compare the 2 hashes, and if they are = then he knows the message is fine
-an attacker could try all the different message combinations that would give u that specific hash
	-this would take 2^N tries however
-Ex:
	sender wants to send dallas is better than boston
		-sends message with hash and signs hash
			-you get integrity (hash) and authenticity b.c. of signature
	an attacker wants to vary message with something that gets the same hash (call these Ms) and he will also have bad messages that change the meaning
	-then he will calculate the hashes of these messages
		M1-h		h'-B1
		M2-h		h'-B2
		M3-h		h'-B3
		.			.
		.			.
		.			.
		MK-h		h'-BK

	-want to find a case where the hash of M = the h' of B
		-odds of this are 2^(N/2) instead of 2^N
	-when this happens the sender is presented with the good message M to sign which he does b.c. the meaning is the same
		-now the attacker will replace the good message with the bad message, but keeps the same signed hash
		-the receiver will be able to verify the authenticity of the message, even though the attacker changed the message
-probability of having 2 people in the room with the same birthday?
	-need 23 people to have a probability higher than 50%
	-where as if you were trying to find someone in the room with a specific birthday you would need many more people in the room (for it to be 50% chance or better)

Popular algorithms
-MD5, SHA-1,SHA-2,SHA-3

MD5
-cracked, but difficult
-still useful for basic things where an attack with strong computing power is not likely
-Message Digest by Ron Rivest
-algorithm takes a message of arbitrary lenght and produces a 128-bit digest
-the resulting digest is the unique "fingerprint" of the original message
-hash is faster than encryption 
-How it works
	-take message, add pad bits
		-have 64 bits at the end
		-so with the message and pad bits, the total message is always a multiple of 512
		-512 - 64 = 448

	Message 	Pad block 	64 bits

	-the 64 bits is just the length of the message in 64 bits
	-the whole thing should
	-always add a pad block
	-after adding the pad block and the 64 bits then the whole thing should be a multiple of 512
	-then chop entire thing into 512 bit blocks
	Ex:
		message is 1024 bits
		512 bits | 512 bits | Pad block | 64 bits
		in this case the pad block is 448 bits

		message is 1012 bits
		512 bits | 500 bits | pad block | 64 bits
		Pad block in this case is 460 bits
-pad is always a 1 followed by 0s
-max length of the message is therefore 2^64 bits
	-if message is longer than this then the 64 bits might just be the last 64 bits of the actual length
-good news with hashes is you don't need to get the message back
	-all you need is a system so that someone can regenerate hash to validate its value
-so once you have blocks of 512 bits then each one is put through MD5.
	-the 128 bit results of the first block is used as input to the hash of the second block 
	-the 128 bit results of the second block is used as input to the hash of the third block etc. etc
	-the 128 bit result of the last block is the digest

SHA-1 
-cracked
-similar process to MD5
-160-bit digest instead of 128 like MD5
-a little more resistance than MD5
-input is processed in 512-bit blocks
-2^80 computations for b-day attack
	-2^64 computations required for MD5 b-day attack

now people use SHA-2 and SHA-3 to be super secure

Compression vs. Hashing
-compressing the media to reduce the number of bits to represent it
	-lossless though, meaning you don't lose any of the information during compression
	-when you reverse it you have the original media
-hashing is lossy, meaning you can't ever get the original message from the hash

HMAC
-developing a MAC derived from a cryptographic hash code
-motivations
	-generally execute faster in software than symmetric block cipher
	-no export restrictions from US or other countries for cryptographic hash code
Ex:
	Message  | H
	-no restrictions b.c. not using a key
	-no authentication though w.o key

	Message | E(H)
	-this has integrity and authentication
	-there were restrictions when this was created that said key has to be 48 bits or less if encrypting
		-wanted to find a way to have a longer key without encrypting

	Message | K | H
	-key is not public, but is secretly shared with receiver
	-basically just add a salt
-so you take a key, compliment half the bits and xor it with an input pad (ipad) and attach this to front of message- then you get Hash version 1
-then compliment the second half of the bits from your key and XOR them with an output pad (opad) and add this onto the front of your hash version 1
	-this result is your HMAC

SSL
-compresses, and then encrypts messages sent
	-this is because adding MACs and stuff adds length so compress
-could compress first so that encryption is faster
	-can't compress something that is already encrypted b.c. a good encryption scheme creates a random pattern of bits which can't be compressed
	-compression uses the pattern of the bits, so if they are random it wouldn't work

How do you share a secret with someone without just giving them the secret, but still prove you knew the secret?
	-Ex: here is a ?, give me the answer
		-instead of giving him the answer I give him some other information
			-just by looking, he can not tell if I actually knew the answer at all, but later I could prove that I knew the answer based on the information I sent
	-hash the answer and send it to him
		-then send the answer later, and if it hashes to the same hash that I had sent then you know I had the correct answer at the time

layers we will talk about

Application(combination of 3 layers)(App, Pres, Session)
	-sending files securely
	-KERBEROS
Transport
	-TCP security
	-SSL
Network
	-IP
	-IPSEC
Data (Link, MAC)
	-802.11
	-Ethernet
	-mac here is media access control
Physical
	-fiber cuts
	-jamming
	-attack on nodes

Bridge protocols to connect b.w. layers that can also be attacked


--------------------------------------------------------


Data and Network Security Lecture 7 Notes

Current Events
Google Doc Space
-if you do security testing, you get 2 GB more space

DDOS attack on Netherlands gov't website

Simple Demultiplexor (UDP)
-Unreliable and unordered datagram service
-adds multiplexing
-no flow control
-endpoints identified by ports
	-servers have well-known ports
-header format
-optional checksum
	-pseudo header
	-UDP header + data
-connection less
	-information in packet tells datagram where to go
-no flow control
	-no logical connection b.w. source and dest.
	-packets can arrive in different seq. then when they were sent
-no error control
	-if a packet gets lost
		-buffer on router is full and packet gets dropped
		-router fails
		-router sent something but link failed
-very fast and cheap
-if not super important that message gets delivered
-diff. from IP in the sense that it is still a transport protocol
-transport level datagram
	-trying to connect b.w. 2 ports on transport level

TCP
-most widely used transport protocol
-reliable data delivery by using IP unreliable datagram delivery
	-IP provides no processing, it just forwards packets
		-best efforts delivery
-compensates for loss, delay, duplication, and similar problems in Internet components
-Reliable delivery is high-level. Familiar model for construction of applications.
-connection oriented
	-when something is lost it can be detected and retransmitted
-end to end
-supports flow control
-transmitting end and receiving end need to go at same speed
-major difference b.w. datagram and connection oriented
	-no need for ACK in datagram
	-don't need to wait for receiver to be read in datagram, you just send when you're ready
	-timing required to not overload receiver
-3 way handshake
	-Active Participant (client) sends SYN to Passive participant (server) with a sequence number X
	-Server responds with SYN + ACK and a new sequence number Y and ACK = X + 1
	-client then sends a response back to server ACK with Acknowledgement = y + 1
	->purpose of sequence number is to make sure they are in order (necessary for flow control, or trying to determine if packets get lost)
		-they are random numbers to start and then keep increasing
			-need to use random # to make sure the protocol does not fail
			-if everyone starts at seq. #0 then there would be a lot of sequences starting at seq # 0
			-makes it easier to distinguish b.w. different connection requests
	-SYN flood is used as a DoS attack


IP for Data Delivery
-TCP uses IP for data delivery (like UDP)
-endpoints are identified by ports
-allows multiple connections on each host
-IP treats TCP like data and does not interpret any contents
-Internet routers only look at IP header to forward datagrams
-TCP at destination interprets TCP messages


TCP uses segments (data) and needs to be put through IP packets
-each layer just wraps the data into a bigger envelope with more headers and flags


In TCP
-modularity is at byte level
-will be dealing with byte streams

TCP segment format

bits 0-15 is SrcPort	
bits 16-31 is DstPort
32 bit Sequence #
32 bit Acknowledgement #
Hdr Len | 0 | Flags | Advertised Window
Checksum | UrgPtr
Options (variable)
Data

the advertised window is to tell the sender how many more packets can be received at the receiver end
	-this is the flow control
	-dest can tell src to slow down if buffer advertisement is full

piggy back acknowledgment
-ACK is included in every packet you send
-idea is don't use a new or separate packet just to send an Acknowledgement
-save network bandwidth
-each individual ACK would include the header as well which is overhead
-could just piggy back onto a message getting sent by sending the ACK as well as the message

TCP Flow Control
-TCP uses sliding window for flow control
-Receiver specifies window
	-called window advertisement
	-specifies which bytes in data stream can be sent
	-carried in the segment along with the ACK
-sender can transmit any bytes, in any size segment, between last acknowled byte and within window size
-could send packets and wait for ACK till sending the next packet
	-stop and wait
	-poor bandwidth utilization but very reliable
-could send as many packets as possible
	-good bandwidth utilization but very unreliable
-Sliding window is a middle ground
	-say window is 10 packets
	-send 10 packets at once, and don't send 11th packet until ACK for first packet is received
		-when it is received window slides one
-if window size is 1 then it is like the first case (stop and wait)

Protocol Suites
			  MIME
			  	|
-BGP FTP HTTP SMTP TELNET     SNMP
  |	  |   | 	|	  |		   |

  		TCP					   UDP
  		 |						|
  		 |						|	ICMP IGMP OSPF RSVP
  		 |						|	 |	   |	|	|
  		 |						|	 |	   |	|	|

  		 		IP
-IP is the base protocol that all of these are built on top of


Internet Design Principles (Original)
-make sure it works
-keep it simple
-exploit modularity (layers)
-expect heterogeneity
-think about scalability
-consider performance and cost

Unfortunately security was not an important consideration when these were being created

Internet Protocol (IP)
-Protocol Stack
	Application
	Transport (TCP, UDP)
	IP
	Network (MAC, Physical)

	H1            R1                R2       R3      H8
	TCP		---IP---		  ---IP--	---IP-     TCP
	IP 		|		|		 |		|	|	 |	   IP
	ETH -- ETH 		FDDI----FDDI	PPP-PPP  ETH--ETH



IP Packet format
32 bits
Version | IHL | Type of Service   | Total Length

	Identification                | Fragmented Offset
  Time to live |  Protocol        | Header checksum
  				Source Address
  				Destination Address
  				Options (0 or more words)

-src address included for 
	-reliability (who sent it, and make sure they aren't lying)
	-quenching 
		-if packet is circulating for way to long sender can stop it from circulating
-time to live
	-Network could get saturated with circulating packets that can't find their destination
	-this will tell router to remove packets
	-it is a counter for the number of hops
		-everytime there is a hop it gets decremented and when it is zero it gets removed from network
-header checksum
	-do a checksum for header as opposed to header for whole message
	-similar to wearing a helmet while riding a bike
		-protect the most important thing
	-if the header is changed even 1 bit then it could be sent to the wrong destination
-fragment offset
	-?? next class we will talk about it


--------------------------------------------------------


Data and Network Security Lecture 8 Notes

Midterm - March 25th

Current Events
bunch of banks got attacked

Service Model
-Connectionless (datagram based)
    -can transmit whatever you have whenever you have it
-Connection oriented
    -hand shake required
    -flow control and error control
-best effort delivery (unreliable service)
	-packets are lost
	-packets are delivered out of order 
	-duplicate copies of a packet are delivered
	-packets can be delayed for a long time

Fragmentation and Reassembly
-necessitated by heterogeneous collection of networks
-every network has its own maximum transmission unit (MTU) (For example, Ethernet 1500 bytes, FDDI 4500 bytes)
-IP has to fit inside the payload of the link layer frames (thus smaller than the max packet size: or ATM networks it ahs to fit inside the CSPDU, further segmentation and reassembly are transparent to IP)
=Host can choose any size it wants, reasonable to select the MTU of immediate network
-To enable reassembly at the receiver, each fragment carries identity
-if any of the fragments do not arrive, the destination discards the arrived fragments
-there is no provision for fragment recovery

Fragmentation Example

Eth frame- can accomodite 1400 bytes-> then goes to FDDI which has a max size bigger than ethernet so no big deal-> then goes to PPP  where max size is 512
	-the packet gets fragmented into 3 packets
	-then it goes back to ethernet but doesn't get reassembled till the receiver
-at receiver, once all fragments are received it reassembles the packet and passes on to TCP
	-if it doesn't get all fragments after a while it drops all the packets
-when fragmented, fragment flag gets set to 1 for all fragments but last
-keep the same message ID so it can group the fragments together
	-uses the offset to know the order of the fragments
-if a fragment isn't received than TCP requests for retransmission

IP Addresses
-IP 4 -32 bits
	-2^32 addresses
-IP 6 -128 bits
	-2^128 bits
-packets will be shipped to destination and when it gets there it should look for destination based on IP
-Routing algorithm to generate route
-if network flag is small then few networks, but large number of hosts and vice versa

Use a subnet mask to determine which bits are network Id and which are used for host ID
Ex: 
	192.28.67.12
	-could have first three section represent the subnet mask
	-if your subnet mask = first couple sections in packet address must match

Address Translation ARP 
-physical interface of the node understands only the addressing scheme of that particular network
-one approach is to put the physical addr in the host part of the IP address inefficient, if not impossible
-ARP enables each node to build a table of mappings 
b.w. IP addresses and link-levl 
-Ethernet uses broadcasting to find a destination for the product.  
-maps physical MAC address to IP address

    
Error Repeating (ICMP)
-Internet control message protocol
-companion protocol where reports certain error or 
 conditions


IntraDomain Routing Protocols
-Routing information Protocol (RIP):
	-distributed along with BSD
	-Uses distane vector algorithm
	-routers send messages advertising their distance to other networks
	-uses a link cost of 1, thus tries to find out minimum hop distance and do not worry about the traffic level or link speed
	-sends the message in every 30 sec. 
	-valid distances are 1-15 and 16 is infinity
-good news spreads fast, bad news spreads slow
	-information about successful paths comes back to sender very fast
-In IP routing always use shortest path
	-doesn't insure quality of service (might be congested or really slow)
-Tunnel means add a header to message


Network Address Translation (NAT)
-can have a few physical IP addresses, and then 50+ internal IP addresses
-packets come to NAT-it translates it to correct address
-they use the port # in conjunction with your IP address

Dynamic Host Configuration Protocol
-scalable
-when you connect you go through the DHCP to get your dynamic IP address
-it dynamically allocates IP addresses

MAC Layer
-Medium Access Control
	-aloha, slotted aloha, CSMA, CSMA/CD, CSMA/CA
-Ethernet
	-uses CSMA/CD

Aloha
-whenever had something to transmit it transmits
-waits for acknowledgement to confirm
-if anyone sends something at the same time as me then there is interference and I will not get ACK
	-retransmit
	-< 30 percent efficiency
Slotted Aloha
-can only transmit something at the beginning of a time slot
-increases efficiency a lot, because now interference can only occur at the beginning of a transmission vs. at anytime during the transmission
-either no interference at all or 100% interference

CSMA
-carrier sense multiple access
-before you transmit you monitor network to make sure no one is trying to send something as well
-if they are not then you send
-can be collisions because transmission time has lag time for when 2 could send at once

CSMA/CD
-CSMA but now you wait for collision and monitor it
-you wait a random amount of time and then try to retransmit

SMU network
-Multiple networks connected through bridges
-some automated protocols (STP) spanning tree protocols
	-spanning tree connects all networks but gets rid of loops
-bridges go through an election process to determine who root bridge is going to be
	-send packets to the rest of the network and claim you have the lowest bridge id so that you can be the root bridge
		-all packets come through you
-bridges use a forwarding table to figure out where all the packets should go
	-when a frame comes it gets broadcast to all ports
	-bridge doesn't know where B is, but it takes A's frame and broadcasts it to all ports
	-when B sends its response to A, the bridge knows where A is
	-the bridges go through a learning algorithm where it keeps track of where ports its received packets from are
-can attack this aspect
	-send lots of spurrious packets saying that they are coming from this and this ID
	-when it receives a packet and doesn't know where to send it it will broadcast it
		-if its broadcasting every packet it slows down the network (DoS attack)

Repeaters

Bridge and Switch and Hub used synonymously
-each ethernet device is connected to a hub
	-max speed you can switch at with a hub is max
-if the devices our connected with out a hub it slows down switch speed (3 devices, 1/3 speed)

-------------------------------------------------------

 Data and Network Security Lecture 9 Notes

 reasons for so many attacks
 -social engineering, reporting is slow

 Repeaters, Hubs, Bridges, Switches, Routers, and Gateways
 -Bridge-> mac layer device connected multiple lans
 	-aka switch- layer 2 device
 -router is layer 3 device
-repeater-repeats the protocol information
		-whether you use copper or fiber, at some point the signal will wane
		-it repeats the information 
-as you move high layer to lower layers you add headers
and tails

Virtual LANs
-when multiple LAN segments you use bridges
-if 100s of LANs a company would like to have separation b.w. these LANs
-intead of having multiple physical LANs, you have 1 LAN with multiple LANs on it
	-have more headers

The Application Layer
-DNS - Domain Name system namespace
	-.com .io .gov .edu , etc..
-assume trying to connect to a host that has never been visited before
	1. Try to access cs.cme.edu
	2. Go to Root bridge and ask for translation on how to get there
	3. Bridge sends back info on getting to .edu server
	4. .edu sends back info on how to get to princeton server
	5. princeton server sends back information on how to get to IP of cs
-really slow, so use a DNS cache to keep track of these visited IPs
	-IPs can change, so the cache needs to be refreshed at some point
-DNS poisoning
	-if the IP gets translated to the wrong IP then they get redirected to my site, I have them authenticate, steal there info and then redirect them to correct site (pharming)

-When you go to a Starbucks, an attacker can create a base station on their computer that sounds like Starbucks wifi
	-then when you connect they can monitor all your packets and steal your bank statements
	-use VPN to avoid this

E-mail Protocol
-everyone has mailbox
-mail server for the company
	-all mail for whole company goes through server
-asynchronous 
	-can send information to anyone at anytime
-sending use SMTP (protocol)
-receiving you use POP3
-still sends body in ASCII characters

now we have MIME encoding
-like base 64 coding
	-taking a random binary pattern into ASCII format
	-main protocol will only use ASCII-> some systems can't handle binary, but they can all handle ASCII
-take 24 bits at a time and divide that into 6 equal parts that will be read as an ASCII character
-will codes 6 bits in 4 groups (64 ?)

-email could be sent 80 miles and then get to our mail server and they encrypt it for the last mile
-if someone is trying to attack you directly they will monitor the last mile of traffic coming into you
	-if this is encrypted you are protected
-if someone is just randomly looking at network to get any juicy info in general they will still get it

-To send an email encrypted all the way through use PGP
	-provides end-to-end protection by encrypting whole payload
	-uses PKI
	-not uses as much b.c. heavy duty
	-doesn't work unless both parties are using PGP

-if you want 

HTTP
	-run on top of TCP
	-client server go through TCP handshake
	-then make HTTP request and response
	-old HTTP had to reestablish connection every time request is made
	-now their is persistent connections
-stateless protocol
	-doesn't keep any history of what you did before or after
	-makes it highly scalable
	-cookies allow connection to expedited
-in-band
	-using same band or channel used for voice

FTP
-stateful
-out-of-band
	-using a dedicated signal different than band used for voice
-built on top of TCP
-should only use SFTP b.c. FTP is not secure at all


Kerberos
-authentication protocol
	-symmetric key
-a TTP gets a ticket to get key
-then go to server to get the ticket
-information is sent to you encrypted
-stateless
	-very scalable
-every time somebody wants something the server encrypts it in its own key
-mostly used by local systems

2 parties
A wants to Authenticate to B
If secret key
1. A sends nonce to B
2. B responds to A with encrypted nonce and a second encrypted nonce
3. A responds to B with decrypted second nonce
4. B says OK lets connect

Using a TTP-public key
-both A and B will use TTP to get public keys

Using a TTP-symmetric key
-all connections will happen with keys b.w. nodes and TTP
-A says to TTP I want to connect to B
-TTP responds to A with a key encrypted using Bs Public key
-A encrypts this with the key they will share using its private key and sends it to B
-B sends this to the TTP which can decrypt it using As public key and send it to B
	-B can decrypt original message and now they both have shared key
-vulnerable to Replay attack
	-use timestamp 

In slides Read through RPC (remote procedure call)
-built on top of UDP
-one of most vulnerable protocols

Familiarize yourself with wireless protocols
Host vs SSID vs base station
How do you make wireless secure
-have auth password
	-if 1 person loses password then everyone has to use the new password
RC4


-------------------------------------------------------

Data and Network Security Lecture 11 Notes

Current Events

Lenovo is shipping computers with the certificate and private key embedded in code
-Super Phish

Kerberos 
-authentication scheme
-designed for LANs
-uses symmetric key encryption


Needham-Schroeder Protocol
-Original third-party key distribution protocol
-for session b.w. A and B
-Vulnerable to Attacker
	-only works if key is compromised
    -Initial Message from A to B captured in previous instance
    -node who will receive packet may not know that it is already used
    -just add a timestamp to stop

Key Distribution scenario
-2 parties want to authenticate e.o.
-once they authenticate they can share a key for the session to create secure channel
-Uses Key Distribution Center
-KDC has a shared key with every node in system
-A says I want to talk to B to KDC.  by sending
	-ID A, ID B and Nonce
	-includes a nonce to allow A to keep track of message and include time
-KDC responds to A with 
	-a session key K_s and ID of A and B and a nonce all encrypted using shared key b.w. KDC and A
	-Same session key to be used b.w. A and B and the ID A all encrypted using Secret key b.w. B and KDC
-A forwards second part to B who can then decrypt the message and get the ID A and the session key to be used b.w. A and B
-B sends Response to A
	-sends a Nonce encrypted using the Session key
-A responds with a function of the Nonce (like Nonce + 1) encrypted with the session key they share
-now they are both authenticated

Kerberos
-in security, Kerberos is an authentication system based on symmetric key crypto
	-originated at MIT
	-based on work by Needham and Schroeder
	-relies on trusted third party like KDC

Motivation for Kerberos
-authentication using public keys
	-N users -> N key pairs
-authentication using symmetric keys
	-N users require about N^2
-symmetric key case does not scale!
-Kerberos based on symmetric keys but only requires N keys for N users
	-but must rely on TTP (central node)
	-advantage is that no PKI is required

Kerberos KDC
-Kerberos Key Distribution Center or KDC
	-Acts as a TTP
	-TTP must not be compromised
-KDC shares symmetric key K_A with Alice, key K_B with Bob, key K_C with Carol, etc.
	-Master key K_KDC known only to KDC
	-KDC enables authentication and session keys
	-Keys for confidentiality and integrity
	-in practice, the crypto algorithm used is DES (old!)

Kerberos Tickets
-KDC issue a ticket containing info needed to access a network resource
-KDC also issues ticket-granting tickets or TGTs that are used to obtain tickets
-Each TGT contains
	-Session Key
	-User's ID
	-Expiration time
-every TGT is encrypted with KKDC
	-TGT can only be read by the KDC

User comes to work station
-connected to Ticket Granting Server, normal Server you are trying to access, and Authentication Server

Kerberized Login
-Alice enters her password
-Alice's workstation
	-Derives K_A from Alice's password
	-Uses K_A to get TGT for Alice from the KDC
-Alice can then use her TGT (credentials) to securely access network resources - workstation sends request to KDC with public information on Alice
-KDC responds with Session Key S_A and TGT that is all encrypted with K_A
	-not necessary to encrypt TGT b.c. already encrypted, but they do it anyway
-plus: security is transparent to Alice
-Minus: KDC must be secure -- its trusted!

Kerberized Login again
-Key KA derived from Alice's password using an agreed upon function (agreed on by KDC and workstation) located on workstation
-Workstation sends request for TGT to KDC
-KDC creates session key S_A and TGT and sends to workstation encrypted using K_A
-Workstation decrypts S_A, TGT, forgets K_A
-TGT = ID_A, S_A, and its encrypted using K_KDC

Alice Requests Ticket to Bob
-REQUEST = (TGT, authenticator) where
	authenticator = E(timestamp, S_A)
-REPLY = E("Bob", K_AB, ticket to Bob, S_A)
-ticket to Bob = E("Alice",K_AB,K_B)
-KDC gets S_A from TGT to verify timestamp

Alice uses ticket to Bob
-Alice sends (ticket to Bob, authenticator)
	-ticket to bob = E("Alice",K_AB,K_B)
	-authenticator = E(timestamp, K_AB)
-Bob responds with timestamp+1 encrypted with K_AB
	-Bob had to first decrypt "ticket to Bob" to get K_AB which he then uses to verify timestamp

Nonce uses a 3 way handshake
	-initial nonce
	-response with nonce +1
	-final response saying authenticated
Timestamp
	-Timestamp encrypted with K_AB
	-acts like a nonce known to both sides
	-Note: time is a security-critical parameter

Kerberos Alternatives?
-could have Alice's workstation remember password and use taht for authentication
	-then no KDC required
	-but hard to protect password on workstation
	-scaling problem
-could have KDC remember session key instead of putting it in a TGT
	-then no need for TGT's
	-but stateless KDC is a big feature of Kerberos

Kerberos Realms
-Kerberos environment consists of
	-Kerberos server
	-number of clients, all registered with server
	-application servers, sharing keys with server
-realm typically a single administrative domain
-in case of multiple realms, their Kerberos servers must share keys and trust

------------------------------------------------------

Data and Network Security Lecture 12 Notes

Current Events 
-Uber has many compromised drivers information

------------------------------------------------------

Data and Network Security Lecture 13 Notes

HW2

Design an encryption system using hash
-could use key and then generate a hash out of it
-could then be used as a one time pad

plaintext XOR 1 time pad

1 time pad made with hash and encryption key
-for each 128 bits-> could hash the hash again
-as long as receiver knows key then they can recreate the 1 time pad


Current Events

-federal aviation and cyber sec of airplanes
	-flight logs, traffic, weather, 
	-long flights make it real easy to break into some of the systems

-new attack on SSL called FREAK that gives people access to keys for EC2 in 7 hours

-attacks where you force OS to use a worse encryption scheme and then attack that lower level

target attack
-put malware in all Point of Sale devices and skimmed memory for information on credit cards

What is PKI ( public key infra)
-pervasive security infrastructure whose services are implemented and delivered using public-key concepts and techniques
	-secure sign-on
	-end-user transparency
	-comprehensive security

Business Drivers
-cost savings
-inter operability
-uniformity
-potential for validation/testing
-choice of provider

Components and services
-certification authority
- certification repository
- certification revocation
-key backup and recovery
-automatic key update
-key history
-cross-certification
-support for non-repudiation
-time stamping

Certificates
-certificates vs signature
-types of certificates
	-X.509(v1,v2,v3)
	-Simple public key infra (SPKI) certificates
	-PGP certificates
	-attribute certificates

Public key Certificates
-certificates allow key exchange without real-time access to public-key authority
-a certificate binds identity to public key
	-usually with other info such as period of validity, rights of use, etc.
-with all contents signed by a trusted Public-key or CA
-can be verified by anyone who knows the public-key authority's public-key

-A submits public key it generated of A to CA
-CA responds with a certificate signed using CAs private key (C_A) including- timestamp, ID of A, and the pub key A submitted
-B submits its own key to CA using same process
-when A wants to talk to B it sends C_A to B and when B wants to talk to A it sends C_B to A

Certificate Format
-version number
-serial number
-signature algorithm identifier
-issuer name
-period of validity
-subject name
-subjects public key info
-issuer unique ID
-subject Unique ID
-extensions
-signature
---> all encrypted using CAs private key

Obtaining a certificate
-any user with access to a CA can get any certificate from it
-only the CA can modify a certificate
-because cannot be forged, certificates can be placed in a public directory

Certificate Path Processing
-eventual objective is to determine whether the key in a given certificate can be trusted
	-path construction - aggregation of certificates to form a complete path
	-path validation - validating each certificate in the path
Target certificate is trusted only if every certificate in the path are trustworthy

-you validate the certificate coming form someone using your CA path

-can have two CAs mutually authenticate

Certificate Revocation
-certificates have a period of validity
-may need to revoke before expiry
	-user's private key is compromised
	-user is no longer certified by this CA
	-CA's certificate is compromised
-CA's maintain list of revoked certificates
	-the Certificate Revocation List (CRL)
-users should check certificates with CA's CRL

-------------------------------------------------------

Data and Network Security Lecture 14 Notes

-CIA and other gov't groups tried to infect Xcode

midterm is on April 1st

Layers of security

HTTP FTP SMTP 				HTTP FTP SMTP
TCP 						SSL or TLS
IP/IPSec 					TCP
 							IP
(a) network level           (b) Transport Level

	S/MIME PGP SET
Kerberos SMTP HTTP
UPD TCP
IP

(c) application level

Socket Layer
-socket layer lives b.w. application and transport layers
-SSL usually lies b.w. HTTP and TCP

				Application - user
socket "layer"->			
				transport ---- OS
				network   ---- OS
				link      ---- NIC
				physical  ---- NIC


What is SSL?
-SSL is the protocol used for most secure transactions over the internet
-you want to buy a book at amazon.com...
	-you want to be sure you are dealing with Amazon (authentication)
	-your credit card information must be protected in transit (confidentiality and/or integrity)
	-as long as you have money, Amazon doesn't care who you are (authentication need not be mutual)
-usually client authenticates the server - they don't care who you are as long as you pay

SSL History
-evolved through
	-unrelased v1 (netscape)
	-flawed-but-useful v2
	-version 3 from scratch
	-standard TLS 1.0
		-SSL 3.0 with minor tweaks, hence version field is 3.1
-Defined in RFC2246
-Open source implementation
	- openssl.org
-no guarantee of sec at client or server, just on pipe

difference b.w. ssl or vpn
-ssl is right below application
	-it only protects that one connection
-vpn is in ip layer
	-everything is protected


Overview
-establish a session
 	-agrees on algorithms
 	-share secrets
 	-perform authentication
-transfer application data
	-ensure privacy and integrity

-ssl is like pki


SSL architecture
-SSL Connection
	-transient, peer-to-peer, communications link
	-associated with one SSL session
-SSL session
	-an association b.w. client and server
	-created by the handshake protocol
	-define a set of cryptographic parameters
	-may be shared by multiple SSL connections
-record protocol to transfer application and TLS information
-a session is established using a handshake protocol

handshae protocol | change cipher spec | alert protocol

		TLS 		RECORD 			PROTOCOL

-establish conneciton, handshake, record layer

Handshake
-negotiate cipher-suite algorithms
	-symmetric cipher to use
	-key exchange method
	-message digest function
-establish and share master secret
-optionally authenticate server and/or client

SSL Messages
-client initiates connection (Hello)
-server sends back protocols it supports and cert.
	-the cert has the server's public key authenticated by a CA root
-when the client authenticates, all it can say is that this is Amazon's certificate.  No saying if Amazon was actually the one to send it
	-okay b.c. without private key of Amazon it doesn't matter
-then they exchange a private key to send data with

-compromise certificate is only way MiM attack could happen

-server sends a chain with a CA root

-can get numerous keys from 1 certificate by subsequent hashing

If client sends A,B,C it hashes everything signs it and sends packet

client hello
-uses time of day and pure random number, so no replay attack

-when you have session ID already a lot of the 10 steps get skipped

-compress and then encrypt
	-encryption takes longer so compressing it will speed it up
	-also encryption schemes are supposed to return a random pattern, which can't be compressed

cipher suite
-public key scheme
-secret key scheme
-hash scheme

Server hello
-version, random #, session ID, cipher suite, compression method

Validating a certificate
-must recognize accepted CA in certificate chain
-must verify that certificate has not been revoked

Client Key Exchange
-premaster secret
	-created by the client used to "seed" the calculation of encryption parameters
	-usually 2 bytes (SSL)

Master secret is generated from Certificate

-premaster secret, client generated #, server generated #
	-these values are usued for SSL connections

-line up these values and add ASCII A
	-put it through SHA and then append to premaster secret and run it through MD5
	-makes up first part of master secret
-repeat this with BB and CCC
-these make up the three parts left to right of master secret
-both client and server go through same process to get mastersecret

-could repeat a second time to get second key

-from master secret you generate hashses and you get all needed keys
	-use different keys for everything as added protection

SSL Record Protocol Services
-Message integrity
	-using a MAC with shared secret key
	-similar to HMAC
-confidentiality
	-using symmetric encryption with a shared secret key defined by handshake protocol

-more expensive to send data with public key

SSL Record Protocol
-chop data into smaller pieces
-compress it
-add a MAC 	-> adding a hash 

Record Header
-3 pieces of information
	-content type
		-applicaiton data
		-alert
		-handhskae
		--change-cipher-spec

Alerts and closure
	-conveys SSL-related alerts to peer entity
	-severity
	    -warning or fatal
	-specific alert
		-fatal: unexpected message, bad record mac, decompression failure, handshake failure, illegal parameter
		-warning: close notify, no certificate, bad certificate, unsupported certificate, certificate revoked, certificate expired, certitificate unknown
	-compressed & encrypted like all SSL data

change cipher spec
-switch to newly negotiated algorithms and key material
-finished
	-first message encrypted with new crypto parameters
	-digest of negotiated master secret, the ensemble of handshake messages, sender constant 
	-HMAC approach of nested hashing

Session vs. connection
-ssl session is established as shown on previous slides
-ssl designed for use with http
-one session can be used for multiple connections
	-each connection will have their own keys, but same master secret
-http usually opens multiple simultaneous connections


-------------------------------------------------------

Data and Network Security Lecture 15 Notes


-passwords are stored in hash, not plaintext
-hash
	-fixed size and efficient
-digital signature
	-you hash, and then sign it
	-more efficient

-biggest difference b.w. password and key is computer generates key

-computer can try a 32 bit key in 1 second

-2 bit key
	- 00
      01
      10 
      11
-3 bit key
		000
		001
		010
		011
		100
		101
		110
		111
-4 bit key
	requires 16 times work 

-6 bits
	-requires 64 times work

27 bits
- 2^25 = 32 million

if 32 bit key takes 1 second
64 bit takes 2^32 seconds
	= 128 years

-64 to 128 bits
	-1 sec = 32 bits
		128 bits = 2^96 seconds


16 million words

-hash to 256 bits

needs 2^24 amount of work

2 1
4 2
8 3 
.
.
1000 10
1000000 20

so 16,000,000 = 2^4* 2^20 = 2^24

Diffie-Hellman key exchange
- session based pki
-first thing you do is pick a #

-want it to be random
	-could get 11 or 12 bits of randomness from hashing time
	-best is nuclear decay and geigan counter
	-lava lamp is random
	-to get a large amount of bits from small random source you can just repeat the random bits

-measure for randomness in a bit is entropy




have a number with 32 bits of security and need 256 bits
-go back to how you picked the 32 bits (the random source) and do it enough times to get 256 bits (8 times)

Entropy of these 2 bits
10

P(1)* log(1/P(1)) + P(0)*log(1/P(0))

50 50 of each = 1 bit of entropy
40 60 = .97 bits
30 70
20 80
0  100 = 0 bits


TTTT_TTTTT

-if this was a heads it would add more randomness to the string (it is expected to happen less)
-would add to the entropy of the list
-if it happens less often it happens less often, and gives more bits of entropy or information


computers have enabled authentication and non-repudiation
-also sharing secret keys

Quantum Computing
-way of allowing you to predict what a particle will be
-have bits that are 1, 0 and qubits that are a 1 and 0 at the same time (superposition)
-when you observe the particle it changes position

-2 slit experiment
	-shoot electrons through 2 slits
	-functions like 2 pebbles dropped in a pond would
	-interference pattern from the ripples
	- even if only 1 electron is being shot, it functions as if it went through both slots because still interference pattern
	-if you put a camera behind it, you no longer have interference pattern, it goes back to functioning if only 1 electron was shot

-D-wave
	-512 qubit computer
	-make use of superposition

-factoring normal is exponential, but with quantum computing it becomes quadratic 
	O(n^2)

-if it goes up by a factor of 5, the computation only goes up by a factor of 25

-if you have something you want to keep secret, don't put it in electronic form

-makes stuff like RSA obsolete because we will be able to do the factoring of some of these algorithms

-for the future
	-they've hypothesized and this has been done in lab that we can tell if someone is listening


-you use quantum channel to exchange a 1 time pad
	-you can only use them once so you have to do it once for every message
-verify no one is listening by sacrificing bits from quantum channel by verifying you and sender have same bits over clear channel
-lose 50 percent of bits so don't send messages over quantum channel

-if bits over quantum channel are totally random then 1 bit of entropy for each bit
-no information content comes through 



-------------------------------------------------------


Data and Network Security Lecture 16 Notes

-presentations should be 25-30 minutes
-just do a reasonable job

-could either record and send video link
-or make presentation and add talking points

TCP is streaming

SSL record protocol
-they don't want for whole tcp session to end to determine if it was protected

-in ssl every record during session is protected
-if attacker is in between
	-he can capture the packets and reorder or delete records if he wanted

-every record has confidentiality and integrity so how do you prevent reordering
	-you add a sequence #
	-used in SSL to prevent reordering

-MAC is created from 
	K	 | seq.#	|	 Headers | Data
-hashed into MAC (HMAC)

-data and MAC are encrypted 
-reciever will generate MAC and if it has changed then integrity violated
-so headers are paintext, but protected with MAC

-could still do replay if you take all packets from a session
	-instead you use a nonce to verify start of new session

Key Exchange
-client says hi
-servers responds hi with his public key signed by CA
-client respond with premaster key
-they both generate master key from premaster key based on agreed upon algorithms

-secret keys are regenerated using premaster key

-all relies on certificate form CA


RSA
-PKI scheme to exchange keys

diffie-hellman
-PKI scheme to exchange keys

	A 					B
	g^a 				g^b

-everyone knows P

A creates a number g^a and publishes that
B creates a number g^b and publishes that

a and b are secret
-a sends g^a
-b sends g^b

-a calcualtes g^ba and b calcualtes g^ab
-so now they have a shared large prime number without knowing each others secret keys
-can get a new secret anytime you want by changing #
-can just say ill take first 128 bits of g^ab

diffie-hellman has MiM attack vulnerability

A -> g^a - C makes g^ac and sends g^c to A
-so A thinks hes talking to B

B -> g^b - C makes g^bc and sends g^c to B

-now A and B think they have authenticated correctly
-anonymous diffie-hellman
-need to authenticate each other using a certificate

still use diffie-hellman so that you aren't transmitting secret key

-ephemeral key
	-don't need public key for anything but authentication

most time consuming part in handshake
-public key cryptography
-want to only have to do this once per session
-SSL has an efficient protocol for opening new connections given an existing session
-will have a session ID cache somewhere
-now in hello message, the client will provide a session ID and the server will go into its cache and provide a session ID
-handshake finishes using final message
	-hash all messages received thus far and compare

-IP gives not much value
-not included in auth process
-if client doesn't have same contents then client can not connect

SSL
-2-10 times slower than TCP
	-handshake phase
		-client does public key encryption
		-server does private-key encryption (still public-key cryptography)
		-usually clients have to wait on servers to finish

SSL attacks
-certificate attacks
-timing attack

Timing Attack
-get certificate from server and send secret to server encrypted with servers public key
-can look at how long it takes server to decrypt and then you can determine what the bits are
-although lots of noise in network delaying things
-can do multiple attacks
-good attack because linear

ssh created b.c. of attack on rlogin
-2 machines
-connect through secure tunnel, and then authenticate 



-------------------------------------------------------


Data and Network Security Lecture 18 Notes

- review for exam

-------------------------------------------------------

Data and Network Security Lecture 19 Notes
- EXAM

-------------------------------------------------------

Data and Network Security Lecture 20 Notes

Test
-lowest 40
-highest 93
-average 73.69
-median 77

-each small problem worth 8 points

Reason for using OFB
-feedback happens before cipher
	-error will not propagate

If you use a hash chain use a backward chain 
-could keep only 1 hash, but each time the hash changes
	-use n-1 for each hash

Diffie-Hellman
	-has M in Middle attack
	-authentication fixes that
	-can't be used for encryption

various scenarios for a certificate to go bad
	-key is compromised
	-they have a revocation list

SSL
	-want security on top of TCP
	-with SSL records you can delete insert, and change order
	-when you make the MAC inside the record there is a sequence # that doesn't get transmitted with header
	-need MAC and sequence number for full credit

N=33, e=3
p=11, q=3
phi(N) = 20
d = 7

M = 25 	M^e mod n = 16


Why is it a bad idea to use the same RSA key pair for both encryption and decryption
-if somebody gives you a message to sign, they could give you a cipher 
	-by you signing it you would have been decrypting it actually

Timestamps for authentication
-prevent replay
	-could also be prevented with nonces
-will reduce the number of messages going back and forth
-disadvantage
	-both parties have to have the same time

Kerberos Login why is TGT sent to user and not just log you in
	-keeps it stateless
		-they don't have to keep track of everything

DES
	-first the attacker reduces the strength of the encryption
		-use hash to make sure all the messages match
	-second they don't even support the encryption
		-the connection would just be terminated

No Authentication
-M in the Middle attack

Final is a little comprehensive
-70-30 break between second part and first part

--end of post test review

IPSEC and SSL
-IPSec lives at the network layer
-IPSec is transparent to applciations
-users don't have to worry about it

application
			<---SSL
transport
network 	<---IPSec
link
physical

IPSec
-general IP security Mechanisms
-provides 
	-authenticaiton
	-confidentiality
	-key management
-applicable to use over LANs, across public and private WANs and for the internet

Benefits of IPSec
-in a firewarll/router provides strong security to all traffic crossing the perimeter
-is below transport layer, hence transparent to applications
-can be transparent to end users
-can provide security for individual users
-secures routing architecture

IPSec and Complexity
-IPSec is very complex
-over-engineered
	-lots of generally useless features
-flawed
	-some serious security flaws
-interoperability is serious challenge
	-defeats the purpose of having a standard
	-standards are there, but in spite of that there is enough variability that it is still not interoperable

IKE and ESP/AH
-2 parts to IPSec
-IKE internet key exchange
	-secure key exchange b.w. 2 parties
	-mutual auth
	-two pahses
-ESP/AH
	-ESP:Encapsuating security payload --for encryption and/or integrity of IP packets
	-AH: authentication header -- integrity only

IKE
-2 phases
	-phase 1 - IKE security association (SA)
	-phase 2 - AH/ESP security association
-phase 1 is comparable to SSL session
-phase 2 is comparable to SSL connection
-not an obvious need for 2 phases in IKE
-if multiple Phase 2s do not occur, then it is more expensive to have 2 phases

IKE Phase 1
-four differnet key options
	-public key encryption (original version)
	-public key encrytption (improved version)
	-public key signature
	-symmetric key
-for each of these, 2 different modes
	-main mode
	-aggressive mode
-there are 8 versions of IKE phase 1

-these are all different ways of using Diffie-Hellman

IKE Phase 1
-well discuss 6 of the 8 variants
-why public key encryption and public key signatures?
	-always know your own private key
	-may not (initially) know other side's public key

IKE Phase 1
-uses ephemeral Diffie-Hellman to establish session key
	-achieves perfect forward secrecy (PFS)
	-once encrypted if someone gets the cipher it won't matter because the secrets are destroyed
-Let a be Alice's Diffe-Hellman exponent
-Let b be Bob's Diffie-Hellman exponent
-Let g be generator and p prime
-Recall p and g are public

Digital Signature: Main Mode
-Alice sends IC and CP
-Bob responds IC,RC,CS 
-Alice responds IC, RC, g^a mod p, R_a
-Bob responds IC, RC, g^b mod p, R_b
-Alice responds IC,RC,E("Alice",proof_A,K)
-Bob responds IC,RC,E("Bob",proof_B,K)
-CP = crypto proposed
-CS = crypto selected
-IC = initiator cookie
-RC = responder cookie
-RA,RB = different, random numbers for nonces
-K = h(IC,RC,g^(ab) mod p, R_a,R_b)
-SKEYID = h(R_a,R_b,g^(ab) mod p)
-proof_A = [h(SKEYID,g^a,g^b,IC,RC,CP,"Alice")]_Alice
-because of proof_A and proof_B prevents man in the middle attack
	-packet will just be discarded
-K available to only Alice, Bob and potentially man in the middle attacker
	-however even if attacker has K, the proof_A and proof_B would not be there

Public key signature (aggressive mode)
-Alice sends IC, "Alice",g^a mod p, R_A,CP
-Bob responds IC,RC,"Bob",R_B,g^b mod p, CS, proof_B
-Alice responds IC,RC,proof_A
-main difference from main mode
	-not trying to protect identities
	-cannot negotiate p and g
-anonynimity not provided so only 3 steps necessary

Symmetric key (main mode)
-Alice sends IC,CP
-Bob sends IC,RC,CS
-Alice sends IC,RC,g^a mod p, R_A
-Bob sends IC,RC,g^b mod p, R_B
-Alice sends IC, RC, E("Alice",proof_A,K)
-Bob sends IC,RC,E("Bob",proof_B,K)
-same as signature mode except
	-K_(AB) = symmetric key shared in advance
	-K = h(IC,RC,g^(ab)mod p, R_A,R_B,K_(AB))
	-SKEYID = h(K,g^(ab) mod p)
	-proof_A = h(SKEYID,g^a,g^b,IC,RC,CP,"Alice")
-main difference is shared secret (private key vs public key encryption)
-exchanged K is dependent on K_(AB)
-not useful, b.c. designed to prevent knowing ID of sender, but in order to figure out K_(AB) and decrypt you need the ID of the sender

Symmetric Key (Aggressive Mode)
-Alice sends IC, "Alice",g^a mod p, R_A,CP
-Bob responds with IC,RC,"Bob",R_B, g^b mod p, CS, proof_B
-Alice responds with IC,RC,proof_A
-same format as digital signature aggressive mode
-not trying to hide identities
-as a result does not have problems of main mode
-but does not (pretend to) hide identities

Public key encryption (main mode)
-Aice sends IC,CP
-Bob respodns with IC,RC,CS
-Alice sends IC,RC,g^a mod p, {R_A}_Bob, {"Alice"}_Bob
-Bob responds with IC,RC,g^b mode p, {R_B}_Alice,{"Bob"}_Alice
-Alice responds with IC,RC,E(proof_A,K)
-Bob responds with IC,RC,E(proof_B,K)
-K = h(IC,RC,g^(ab) mod p, R_A,R_B)
-SKEYID = h(R_A,R_B,g^(ab) mod p)
-proof_A = h(SKEYID,g^a,g^b,IC,RC,CP,"Alice")

Public Key Encryption (Aggressive mode)
-Alice sends IC,CP,g^a mod p, {"Alice"}_Bob,{R_A}_Bob
-Bob responds IC,RC,CS,g^b mod p, {"Bob"}_Alice, {R_B}_Alice, proof_B
-Alice responds with IC,RC,proof_A
-K,proof_A,proof_B computed as in main mode
-Note that identities are hidden
	-the only aggressive mode to hide identities
	-then why have main mode

-this lecture was about IPSec------------
	-2 parts IKE, ESP/AH
	-IKE has 2 phases that, like SSL, is all about establishing session securely so that you can have multiple connections

IKE phase 1
-establish secured assocation for key exchange
-4 different encryption strategies
	-public key encryption original, revised
	-secret key encryption
	-public key signature
	-four each of these you have main and aggressive mode
		-main mode is designed to hide the identity of sender
			-need 6 message exchanges
			-preferred when anonymity is important
		-aggressive mode
			-identity is put out there
			-only need 3 exchanges
			-used when speed is important
	-for the private key modes they need to know who the sender is to be able to use the correct shared private key
		- weakness in the system

IKE phase 2 
-establish secured association for IPSec itself or rather the connection

-------------------------------------------------------

Data Network and Security Lecture 21 Notes

Security News
-Singtell bought a company for 810 million

new Security Directives from White House

Spear Fishing
-more educated phishing

Even if email looks legit, don't click on it

public key
- you have to get their public key where as in signature you already have your private


main mode - hide id's

plausible deniability
-mode where repudiation

IKE Phase 1 Summary
-Result of IKE Phase 1 is 
	-mutual auth
	-shared symmetric key
	-IKE security Association (agreement on what kind of encryption schemes)
	-pahse 1 is expensibve (in public key and /or main mode cases)
	-developers of IKE thought it would be used for lots of things not just IPSec
	-over engineered

IKE Phase 2
-pahse 1 establishses IKE SA
-phase 2 establishes IPSec SA
-Comparison to SSL
	-SSL session is comparable to IKE phase 1
	-SSL connections are like IKE phase 2
-IKE could be used for lots of things
-but in practice its not

IKE Phase 2
-Alice sends IC, RC,CP,E(hash1, SA, R_A,K)
-Bob sends IC,RC,CS,E(hash2,SA,R_B,K)
-Alice sends IC,RC,E(hash3,K)
-key K, IC, RC, and SA known from phase 1
-Proposal CP includes ESP and/or AH
-Hashes 1,2,3 depend on SKEYID, SA,R_A and R_B
-keys derived from KEYMAT = h(SKEYID,R_A,R_B,junk)
-Recall SKEYID depends on phase 1 key method
-Optional PFS (ephemeral Diffie-Hellman exchange)

IPSec
-after IKE phase 1, we have an IKE SA
-after IKE phase 2, we have an IPSec SA
-both sides have a shared symmetric key

IP REview
n IP datagram is of the form

	IP header | data

where IP header is

version | IHL | Type of Service | Total Length
Identification					| |f|f|fragment offset
TTL 	| Protocol 				| Header checksum
Source IP address 				
Destination IP address
Options

IP and TCP
-IP encapsulates TCP
-TCP encapuslates HTTP

IPheader 	| data
IPheader 	| TCP hdr | http header| app data

n IP data includes TCP header, etc. 

Architecture and terminology
-host or gateway implementation
-tunnel vs transport mode
-encapsulating security payload (ESP)
-authentication header (AH)
-security association (SA)
	-security paremeter index (SPI)
	-security policy database (SPD)
	-SA database (SAD)

IPSec placement
-host implementation
	-OS integrated modify the IP code
-bump-in-the-stack
	-layer b.w. data link and IP
-bump-in-the-wire
	-IPSec outside host, ina  router/firewall
	-least intrusive

IPSec Transport Mode

A sends encrypted IP header with ESP/AH header and data

-use one of these keys and make a MAC
-then take these fields and double check they have not changed

IPSec Transport Mode
-IPSec Transport Mode

IPHeader 	| data
IP header |ESP/AH | data
-transport mode designed for host-to-host
-transport mode is efficient
	-adds minimal amount of extra header
-the original header remains
	-passive attacker can see who is talking

IPSec Tunnel Mode
-A unencrypted to gateway- encrypted between gateways- unencrypted from last gatweay to B
-encrypted tunnel
-listener can only tell that 2 firewalls are communicating

New IPHEADER | AH or ESP hdr | orig. IP header|TCP|Data	
Comparison of IPSec modes
-transport mode
	-takes IPheader and data packet and embeds ESP/AH in between
-tunnel mode
	-takes IPheader and data packet and prepends a new IP hdr and ESP/AH to the front of IP header and data
	-this new header gets stripped at the end

Comparison of IPSec modes
-transport mode
	-host-to-host
-tunnel mode
	-firewall-to-firewall
-transport mode not necessary
-transport mode is more efficient

AH vs. ESP
-AH
	-authentication header
	-integrity only (no confidentiality)
	-integrity protect everything beyond IP header and some fields of header (why not all fields)
-ESP
	-encapsulating security payload
	-integrity and confidentiality
	-protects everything beyond IP header
	-integrity only by using NULL encryption

Why does AH exist?
-cannoy encrypt IP header
	-routers must look at IP header
	-IP addresses, TTL , etc.
	-IP header exists to route packets
-AH protects immutable fields in IP header
	-cannot integrity protect all header fields
	-TTL for example must change
-ESP does not protect IP header at all
-ESP encryptes everything beyond the IP header (if non-null encryption)
-if ESP encrypted, firewall cannot look at TCP header (e.g. port #s)
-why not use ESP with null encryption?
	-firewall sees ESP header, but does not know whether null encryption is used
	-end systems know, but not firewalls


-------------------------------------------------------

Data and Network SEcurity LEcture 22 Notes

Security Association- SA
-one way relatinoship (uni-directional)
-dtermine IPSec processing for senders
-dtermine IPSec decoding for destination
-SAs are not fixed! generated and customized per traffic flows (manual as well as dynamic)
	-if no manual, no lifetime, dynamic has a lifetime

Security Parameters Index - SPI
-can be up to 32 bits large
-the SPI allows the destination to select the correct SA under which the received packet will be processed (accoding to the agreement with the sender)
	-the SPI is sent with the packet by the sender
-SPI + DEST IP address + IPSec Protocol (AH or ESP) uniquely identifies a SA

SA Database - SAD
-holds parameters for each SA
	-lifetime of this SA
	-AH and ESP informatino
	-tunnel or transport mode
-every host or gateway participating in IPSec has their own SA database

SA bundle
-more than 1 SA can apply to a packet

Security Policy Database - SPD
-what traffic to protect
-has incoming traffic been properly secured
-Policy entries define which SA or SA bundles to be used on IP traffic
-each host or gateway has their own SPD
-Index into SPD by selector fields
	-dest IP, source IP, Transport Protocol, IPSec protocol, source and destination Ports, etc. 


SPD Entry Actions
-Discard
	-do not let in or out
-Bypass
	-outbound: do not apply IPSec
	-inbound: do not expect IPSec
-Protect - will point to an SA or SA bundle
	-outbound: apply security
	-inbound: check that security has been applied

SPD protect acitno
-if the SA does not exist
	-outbound processing: use IKE to generate SA dynamically
	-inbound processing: drop packet

AH security
-connectionless integrity
	-flow/error control left to transport layer
	-data integrity
-authentication
	-can "Trust" IP address source
	-use MAC to authenticate
-anti-replay feature
-integrity check value

Integrity Check Value - ICV
-message authentication code (MAC) calculated over
	-IP header field that do not change or are predictable 
	-IPSec protocol header minus where the ICV value gores
	-upper-level data
-code may be truncated to first 96 bits

AH header format

Next header 
(TCP/UDP) | payload length | reserved
			SPI
	Sequence Number
	ICV


AH Modes
-Tunnel
-Transport
-Nested headers
	-multiple SAs applied to same message
	-nested tunnels
		-if there is a tunnel from A to D, there can't be one from C to E, but there can be one b.w. B and C

Processing Outbound messages
-insert next header and SPI field 
-Compute the sequence number field
	-if processing < 2^32 message
		-increment
		-place new value in AH and SAD
	-else
		-change keys at wrap around if replay protection is enables
		Else set to 1
-if transport mode, change preceding IP header's Next Header field to AH
-if tunnel mode, add the tunnel header
	-recompute the header length, header checksum, etc.
-compute authentication value
-calculated on entire IP packet including AH header
	-zero out all mutable fields including authenticationdata field
	-get the key from SA
	-HMAC-MD5-96 or HMAC-SHA-96
	-Insert the cryptographic hash code in the AH header
-Fragment the message
	-IPSec processing may result in large message which will be fragmented
		-Transport Mode
			-source address initiator of the message
			-total message auhtnetication b4 fragmentation
		-tunnel mode
			-message may have been fragmented already
			-authenticate the fragment and further fragment
Input processing 
-identify the inbound SA
	-if not found, drop the packet
-repaly protection check
	-drops duplicates within the window
	-drops late arribals outside the window
	-advances with the receipt of authenticated message
-verify auhtentication data
	-authentication hash computed and checked
	-if no match, discard
-strop off the AH header and continue IPSec processing for any remaing IPSec headers
	-either an upper layer protocol header or a tunnel header is encountered

Replay protection
-sequence number checking
	-anti-replay is used only if auhtentication is slected
	-sequence number shoul dbe the first check on a packet upon looking up an SA
	-duplicates are rejected
			 check bitmap verify if new
| reject 	| sliding window size >=32 | verify
0 			n
-sliding window vulnerable to DoS attack

Encapsulated Security Policy (ESP)
-confidentiality for upper layer protocol
-traffic flow confidentiality
-data origin authentication and connectionless integrity (optional)

ESP Packet
-Before Applying ESP
IPV4-> original IP header | TCP header | Data 
-after applying ESP
IPV4->Outer IP hdr| ESP hdr|orig IP hdr|tcphdr 
							<---encrypted-------------
				   <authenticated---------------------
|data|ESP trailer|ESP Auth
------encrypted-->
---authenticated->

Once payload is encrypted the firewall can't look in at TCP headers or anything else

Original IP header
SPI
Seq. #
Payload(TCP header and data)
		variable length
		Padding (0-255 bytes)
				pad length | next header
Integrity check value


SSL vs IPSec
-IPSec 
	-lives at network layer
	-has encryption, integrity, authentication, etc.
	-is overly complex (including serious flaws)
-SSL 
	-lives at socket layer (part of user space)
	-has encryption, integrity, authentication, etc.
	-has a simpler specification

-for hw
	-set up 2 insecure connections on web and use sniffer to look at packets
		-you will see both our open and everything can be seen
	-then do 1 of the connections using SSL and you will see now that only 1 of them is open
	-then tier down your machine and connect to your machine using IPSec and you will see that both packets are protected
	-they are at different levels

SSL vs. IPSec Continued
-IPSec implentation
	-requires changes to O.S. but no changes to applications
-SSL implementation
	-requires changes to applications but no chagnes to OS
-SSL built into web application early on (Netscape)
-IPSec used in VPN applications (secure tunnel)
-Reluctance to retrofit applications for SSL
-Reluctance to use IPSec due to complexity and iteroperability	

-------------------------------------------------------

Data and Network Security Lecture 23 Notes

GSM System Overview

monile air interface to base station - to base controller over landline to AuC
-early forms had almost no protection

Mobile phone
-contains SIM (subsriber identity module)
-SIM is the security module
	-IMSI 
	-User Key Ki (128 bits)
	-Tamper resistant (smart card)
	PIN activated (usually not used)


GSM system components
-visited network
	-base station - one "Cell"
	-VLR (visitor Location register) --info on all visiting mobiles currently in the network
-home network -- "home" of the mobile
	-HLR (home location register) -- keeps track of most recent location of mobile
	-AuC (authentication center) -- contains IMSI/Ki

GSM security Goals
-primary design goals
	-make GSM as secure as ordinary telephone
	-prevent phone cloning
-not designed to resist an active attack!
	-at the time this seemed infeasible
	-today such an ttack is very feasible
-designers considered biggest threats
	-insecure billing
	-corruption
	-other low-tech attacks

GSM security features
-anonymity
	-intercepted traffic does not identify user
	-not so important to phone company
-authentication
	-necessary for proper billing
	-very important to phone company
-confidentiality
	-confidentiality of calls over the air interface 
	-not important to phone company
	-may be very important for marketing

GSM: anonymity
-IMSI used to initially identify caller
-then TMSI (temporary mobile subscriber ID) used 
-TMSI changed frequently
-TMSI's encrypted when sent
-Not a string form of anonymity
-but probably sufficient for most users

GSM: authentication
-caller is authenticated to base station
-auth is not mutual
-authentication via challenge-response
	-home network generates RAND and computes XRES = A3(Rand,Ki) where A3 is a hash 
	-Then (RAND,XRES) sent to base station
	-Base station sends challenge RAND to mobile
	-Mobile's response is SRES = A3(RAND,Ki)
	-Base station verifies SRES = XRES
-note: Ki never leaves home network!

GSM: Confidentiality
-data encrypted with stream cipher
-error rate estimated at about 1/1000
	-error rate too high for a block cipher
-encrpytion key Kc
	-home network computes Kc = A8(RAND,Ki), where A8 is a hash
	-then Kc sent to base station with (RAND,XRES)
	-mobile computes Kc = A8(RAND,Ki)
	-keystream generated from A5(Kc)
-note: Ki never leaves home network

GSM SEcurity
1. User sends IMSI to base station 
2. Base station forwards IMSI to home network
3. Responds to Base station with protected triplet (RAND,XRES,Kc)
4. Base station will respond to mobile with RAND
5. Mobile responds to base station with SRES
6. Base station and mobile can communicate with Encryption with Kc

GSM triplets
-authentication while roaming
	-w.o passing the Ki
-AuC generates (RANd,XRES,Kc) triplets
-passes to VLR
-usually precalculated
-if attack on HLR then theres a problem

GSM insecurity
-hash used for A3/A8 is COMP128
	-broken by 160,000 chosen plaintexts
	-with SIM, can get Ki in 2 to 10 hours
-encryption b.w. mobile and base station but no encryption from base station to base station controller
	-often transmitted over microwave 
-encryption algorithm A5/1
	-broken with 2 seconds of known plaintext
-attacks on SIM card
	-optical fault induction - can attack SIM with a flashbulb to recover Ki
	-paritioning attacks - using timing and power consumption, can recover Ki with only 8 adaptively chosen "plaintexts"
-with posession of SIM, attacker can recover Ki in seconds







-------------------------------------------------------

HW 4
-IPSec Transport Mode
	-end to end encryption
	-A ------- Gateway ---------- Gateway ----------B
	 	encrypted 		encrypted  			encrypted
	-IP HeADER | ESP/AH | data
	-IP header doesn't change, but you add ESP/AH in b.w. header and payload
	-data is not protected
	-no confidentiality, but integrity
	-they use the MAC to add authentication
	-take several fields from header and data and form MAC and put in ESP/AH and make sure not changed
	-trasport mode is efficient
		-adds minimal amt. of extra header
	-passive attacker can see A is talking to B and what they are saying, but can't change data

-IPSec Tunnel Mode
	-A ----------Gateway------------Gateway----------B
	  unencrypted        encrypted         unencrypted
	-attacker can just see the next hop, but can't see if A is talking to B, C, D
	-used often for communication b.w. firewalls
	-confidentiality, b.c. multiple hosts could be connected to same firewall
	- New IP Header | AH or ESP header | orig. IP header | data
	-routers use new IP header to route for the encrypted section
	-after the encrypted section the new headers were stripped off and the original packet is restored
	-i.e. from A to G1 orig. IP header from G1 to G2 is new IP header and from G2 to B is orig. IP header
	-could have a nested tunnel inside this tunnel during which there would be a second new IP header and AH/ESP header on top of the other new one.  The first new one would be considered the orig. IP packet for this nested tunnel

	AH
	-auth header
	-no confidentiality, so just use MACs for integrity
	-payload never changes, so it is okay to use that in the MAC
	-Can't use all of the header fields in the MAC b.c. the TTL changes
		-just use the immutable IP header fields in the MAC (i.e. the source and dest. IP address)

	ESP
		-encapsulating sec payload
		-integrity and confidentiality
		-protects everything beyond IP header with encryption
		-uses NULL encryption for the integrity
			- just means no encryption and it is just like AH
		-if ESP encrypted firewall can not look at TCP header (e.g. port #s)
		-can't use null encryption
			-firewall doesn't know if null encryption is used soo


Replay protection
-seq # checking
-if window starts at N 
	-any packets coming in at id N-1 or lower will be rejected
	-any packets coming inside the range of the window that isn't a duplicate will be accepted
		-duplicate are rejected
	-packets that are above the window will cause the window to advance
	-if 32 slot window and a packet comes in with id N + 32 then the window would advance 1.  
		-if the packet with ID N had not come in yet then it is lost forever, because it would not be accepted now that the window has advanced
-in order to accept a packet first check ICV
	-if ICV passes then move the window by 1
	-if you don't check the ICV before accepting and moving the window then only later will you realize you can reject it
	-someone could send you packets with high seq. #s and then packets will be dropped unecessarily resulting in a DoS attack


IPSec


-------------------------------------------------------

Data and Network Security Lecture 24 Notes


RFID Tags
-used everywhere
-whenever you wanna track an item stick a tag on it
-replaces the barcode
-can read it through an opaque material

Basic Components
-RFID tag
	-transponder
	-located on the object to be identified
-RFID reader
	-transceiver
	-can read and write data to Tag
-Data Processing Subsystem
	-connects to reader

Forward Channel and Backward channel
-when a reader tries to read something
	-its either connected to outlet or has a powerful battery
	-sends out a powerful signal to tag
	-tag sends a weak response back
-the forward range is the range of the reader out to tags
-the backward range is the weak range of the tags response back to the reader
-airplane and garage signal example

May have lots of items stored with RFID tag, but they have to be close to reader for them to work

Security Issues with RFID
-privacy
	-business
	-personal
-denial of service
-incorrect information
-forgeries
	-change the tag information on a walmart tv and pay $2 for it.
	-clone a toll tag and drive through on their expense

Vulnerability Concentration Areas
-market concentration is on the low end
-people are focusing on vulnerability concentration
	-credit cards, medical niches, ePassport

RFID Security Attacks
-cloning
	-included implanted chips (verichip)
	-could make an identical chip
-tracking
	-merchant may track using the transaction counter
-loss of anonymity (military?)
	-big problem in Gulf War
	-by looking at some of the items someone is carrying they can identify them
-skimming
	-Johnny Carson Attack
		-somebody brings envelop and he tries to figure out what is in it
		-idea of someone identifying what is inside something without opening it
		-read information off of it
	-Bump and run etc.
		-someone just comes near your pocket, read the tag and then run
-SQL Injection
	-put some sql injection patterns into card and use it to get access
-Eavesdropping
-replay and relay
	-replay can be thwarted with timestamps, transaction counter, etc.
	-relay is when 2 adversaries could collude to use somebody else's credit card 

Cost-Security Trade-off
-low cost
	-low intelligence (up to 5000 gates)
	-low storage (few hundred bits)
	-low range (few meters)
-security
	-AES needs 20-30 thousand gates
	-Hash such as SHA-1 also needs similar order
	-TEA algorithm still not feasible

Existing Security Solutions
-EPC RFID Tag Kill Command
	-internal kill sequence to make the tag permanently inoperative
	-option to PIN (32 bits) protect against DoS
	-Done at POS
	-not wide-spread b.c. of "return" logistics
		-if someone kills a tag then there is no way for merchant to know if it was actually purchased from that company
-PIN protected READ/WRITE
-Tear-off antennas
-Faraday cages
	-useful for credit cards and e-passports
	-makes it so someone can't read signal until it is opened

Hash-based Access Control
-when a query is given, even on a secure tag, then a tag responds that I am alive
	-tag responds with meta ID not real ID
	-the metaID is sent to the database which gets the key and real ID based on metaID and the key is sent to the Tag and then the Tag responds with the real ID

Randomized Access Control
-in addition to a hash it has a random number generator
and a hash function
-reader sends query to tag
-tag responds with a random number, a hash of (random number and ID)
-this will create essentially a different metaID for each signal
-the reader says to DB send me all IDs
-the reader then goes by brute force and takes the random number with every id and hashes them all to find the matching hash value
-it then knows that the tag is who it says it is and it sends ID to the reader
-brute force takes a while though


Data Leakage from Reader
-probabilistic
	-tags respond in randomly generated times
	-slotted aloha scheme
		-if small amount of tags
		-you try to communicate when ready, and if channel is open then you send, otherwise wait till the next slot and try again
-deterministic binary tree-walking scheme
	-space of k-bit identifiers
	-k-bit identifiers leaves in a tree of depth k
	-reader sorts through tags based on tag-ID
		-Traverse tree asking subsets of tags to broadcast a single bit at a time
	-RFID reader broadcasts tag serial numbers over very large distances
		-may introduce vulnerability to eavesdropping
		-whatever bit the reader is sending out can be read by the eavesdropper
	-reader selects a tag and if both children are equal then thats the response, but if they are different then you choose 1 and move on
	-deterministic (it will converge)

	Ex:
		reader requests signal
			-in its forward range there are 2 tags
			-if they respond on backward channel with the same bit then the reader takes that bit
			-if there is a conflict then it will only allow 1 tag to proceed
				-it will say only tag with next bit = 0 can continue
				-this is sent on forward range though so an eavesdropper from far away gets that bit
			-if the 2 tags differ on every bit then the eavesdropper gets the entire key

-silent tree walking
	-if no conflict then accept that bit
	-if conflict then instead of sending what the next accepted bit is it will take the XOR of the previous bit and the bit he is choosing
	-the eavesdropper won't know what exactly the previous bit was (b.c. it was sent on the backward channel) so it won't know what the current bit is 

Physical Unclonable Functions (PUFs)
-uses inert variations of the manufacturing process
-generates unpredictable response, givena  stimulus (challenge)
-responses are reproducible
-tamper-evident and difficult to clone
-applications
	-challenge-response authentication
	-physical key storage

ring oscillator


A -NorGate- NorGate- NorGAte -XOR-------
|____________________________| 		|
|___________________________________|


One-time pad authentication
-normally replay attack is easy -> just intercept signal, and create clone of RFID tag
-with a unique key for everytime that fixes this problem

OCCRA: Overt-Covert Challenge REsponse Authentication
-authentication and key sharing protocol using embedded sequence of challenge-response pairs
-Advantages
	-low-cost, oracle-based authentication
	-device-centric deployments
		-dont have to transfer any intelligence to it
		-just put circuitry there
	-ownership transfer
	-system scalability
	-multi-user provisions
	-breach recovery
	-volatile-key generation

-lots of startups working on PUFs now


OCCRA Protocol
1. SEtup
	-initialize phase
	-collect some challenge and responses (in a closed room)
	-only server knows r values
		c1 		r1
		c2 		r2
		c3 		r3
		c4 		r4
		c5		r5

2. Authentication phase
	-2 step process
	-atomic
	-1 overt (open) challenge and 1 covert (closed)
		-anyone can see overt challenge
		-covert challenge is encrypted
			-xor of response you could get with open challenge and the challenge itself
		-overt could be c1
			-covert would be r1 XOR c3
	-takes c1, goes to server gets r1 and takes c3 and xors with r1
	-
3. REfresh cycle
	-sometimes need to flush and generate new challenges
4. 

Email Security
-remember ssl doesn't have end to end security
-you can encrypt email at application layer
-PGP - pretty good privacy
	 - uses combo of secret key and public key
	 - A wants to send PGP protected mail to B
	 soo....
	 A signs message with As private key and then randomly pick a secret key for the encryption key
	 ----(but B doesn't know secret key b.c. no handshake)
	 -So A encrypts with secret key and then encrypts secret key with Bs public key
	 -both parties need PGP for it to work


-------------------------------------------------------

Data and Network Security Lecture 25 Notes


Medical Industry
-Jim Lomeo

Sensor Networks
-Jordan Kayse


Automotive Cyber-Physical Security Threats
-Raz Friman

Biometric Security: security at any cost
-Andy Buck

-------------------------------------------------------


Data and Network Security Lecture 26 Notes


SDN Security
-Chris Ayala

Mobile Security
-Peter DeNicola

Scada Security
-Austin Lee

-------------------------------------------------------

Data and Network Security Lecture 27 Notes


--all presentations
-Jeff shaffer

-------------------------------------------------------

Data and Network Security Lecture 28 Notes

4 pages of cheat sheets for final
-comprehensive with more focus on topics after midterm
-3 hour exam, May 11th at 8AM


-------------------------------------------------------

End of Class


















